---
title: 计算机组成原理笔记：指令系统
date: '2025-09-02 21:39:12'
updated: '2025-09-24 00:49:15'
permalink: /post/computer-composition-principle-notes-instruction-system-1lxgsy.html
comments: true
toc: true
---



# 计算机组成原理笔记：指令系统

## 一、指令格式

![](https://mysynotebook.oss-cn-hongkong.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-23%20174602-20250923180844-k4meb7d.png)​

### 1. 基本构成​​

**指令 = 操作码 + 地址码**

|部分|功能|
| ------| ------------------------------------------------------------------------------------------------------------------------------------------|
|**操作码（Opcode）**|表示该指令要执行的操作类型，如加、减、乘、除、数据传送等。<br />其长度取决于指令系统的总指令数（例如：若共有 2^n 条指令，则需 n 位操作码）。|
|**地址码（Address Code）**|指出操作数的位置或值本身。<br />可以是直接给出操作数（立即数），也可以是指向寄存器或内存地址的地址信息。|

示例：

​`ADD R1, R2`：操作码表示“加法”，地址码为两个寄存器名。

​`MOV A, #5`：操作码表示“传送”，地址码中包含立即数 5。

## 二、基本指令格式

![](https://mysynotebook.oss-cn-hongkong.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-23%20174737-20250923180916-bibyjqz.png)​

### 1. 按地址码数目分类

|类型|格式|特点|典型应用|
| ------| ----------------| ------------------------------------------------------------------| --------------------------------------|
|**三地址指令**|OP A₁ A₂ A₃|三个地址分别指向两个源操作数和一个目的地址<br />结构清晰，但指令长|多用于早期计算机或教学模型|
|**二地址指令**|OP A₁ A₂|A₁ 是第一个操作数，A₂ 是第二个操作数兼结果存储位置<br />最常见格式|如：`ADD R1, R2` → R1 ← R1 + R2|
|**一地址指令**|OP A|A 既是操作数地址，也是结果存放地址<br />节省空间，但灵活性差|加1、减1、移位等单操作数指令|
|**零地址指令**|OP|无地址字段，不涉及具体操作数<br />常用于控制类指令|空操作（NOP）、停机（HLT）、关中断等|

注意：

在一地址指令中，**隐含一个操作数**（如累加器 ACC）。同时，零地址指令通常依赖**堆栈结构**实现（如 `PUSH`, `POP`）。

### 2. 按指令长度分类

|类型|定义|优点|缺点|应用场景|
| ------| ------------------| ------------------------------------| ------------------------| ----------------------|
|**定长指令字结构**|所有指令长度相同|控制简单，取指速度快，硬件设计容易|指令功能受限，浪费空间|RISC 架构（如 MIPS）|
|**变长指令字结构**|不同指令长度不同|更灵活，可压缩常用指令，提高效率|控制复杂，取指困难|CISC 架构（如 x86）|

### 3. 按功能分类（7大类）

|类别|说明|典型指令|
| ------| -----------------------------------------| -----------------------------|
|**数据传送类**|实现主存与CPU之间、寄存器之间的数据交换|LOAD, STORE, MOV|
|**算术运算类**|执行基本数学运算|ADD, SUB, MUL, DIV|
|**位操作类**|对二进制位进行逻辑处理|AND, OR, XOR, NOT, SHL, SHR|
|**I/O类**|控制输入输出设备|IN, OUT|
|**串操作类**|处理字符串或数组|MOVS, CMPS, SCAS|
|**CPU控制类**|控制处理器运行状态|CLI, STI, HLT|
|**转移类**|改变程序执行顺序|JMP, CALL, RET, BRANCH|

**LOAD**：从存储器读取数据到寄存器（如：`LOAD R1, [1000H]`）

**STORE**：将寄存器内容写入存储器（如：`STORE [2000H], R1`）

## 三、操作数类型及操作类型

### 1. 操作数类型

|类型|描述|示例|
| ------| --------------------------------------------------| ----------|
|**立即数**|操作数直接出现在指令中|​`ADD R1, #5`​|
|**寄存器**|操作数在寄存器中|​`ADD R1, R2`​|
|**直接寻址**|地址字段直接给出操作数的物理地址|​`MOV R1, [1000H]`​|
|**间接寻址**|地址字段指向另一个地址，该地址才是操作数所在位置|​`MOV R1, [R2]`​|
|**寄存器间接寻址**|寄存器中保存的是操作数地址|​`MOV R1, [BX]`​|
|**基址寻址**|EA = 基址寄存器 + 偏移量|​`MOV R1, [BX+100H]`​|
|**变址寻址**|EA = 变址寄存器 + 偏移量|​`MOV R1, [SI+10H]`​|
|**相对寻址**|EA = PC + 偏移量|​`JMP +100`​|
|**堆栈寻址**|使用栈顶指针 SP 访问数据|​`PUSH R1`, `POP R2`​|

⚠️区分关键：

**基址 vs 变址**：

- 基址：固定段基址 + 偏移 → 用于模块定位
- 变址：动态索引 + 偏移 → 用于数组遍历

**间接寻址 vs 寄存器间接寻址**：

- 间接：内存中存地址；寄存器间接：寄存器中存地址

### 2. 操作类型总结

|类型|功能|代表指令|
| ------------| ----------------------------| ------------------------|
|数据传送类|CPU与主存/寄存器间数据传输|LOAD, STORE, MOV|
|算术运算类|数值计算|ADD, SUB, MUL, DIV|
|逻辑运算类|位级操作|AND, OR, XOR, NOT|
|控制转移类|改变程序流程|JMP, CALL, RET, BRANCH|
|I/O类|与外部设备交互|IN, OUT|
|串操作类|字符串批量处理|MOVS, CMPS|
|CPU控制类|控制CPU内部状态|HLT, CLI, STI|

## 四、寻址方式

![](https://mysynotebook.oss-cn-hongkong.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-23%20175520-20250924004518-6f6qh8t.png)​

## 1. 基本概念

**数据寻址**：指令执行时，根据地址码字段确定操作数真实位置的过程。  
目标是计算出**有效地址 EA（Effective Address）** ，进而取出操作数。

操作数可能来自：

- 指令本身（立即数）
- 寄存器
- 主存（需地址访问）

## 2. 8种常见寻址方式

![](https://mysynotebook.oss-cn-hongkong.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-23%20175712-20250924004414-qs4ammv.png)​

![](https://mysynotebook.oss-cn-hongkong.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-23%20175908-20250924004604-uxrihit.png)​

|图示|名称|EA计算公式|是否访存|特点与用途|
| ------| ----------------| ----------------------| ----------| -------------------------------------------------------|
|(a)|隐含寻址|固定寄存器（如AC）|❌|指令不写地址，操作数默认在指定寄存器中，如 `INC AC`​|
|(b)|立即寻址|EA = D（指令中的数）|❌|操作数直接写在指令里，如 `ADD R1, #5`，速度快但不可变|
|(c)|直接寻址|EA = A（地址字段）|✅|地址A直接指向内存单元，如 `MOV R1, [1000H]`，简单但地址空间受限|
|(d)|间接寻址|EA = (A)|✅×2|地址A指向“地址的地址”，支持指针，如链表访问，速度慢|
|(e)|寄存器寻址|EA = R（寄存器内容）|❌|操作数在寄存器中，如 `ADD R1, R2`，速度最快，最常用|
|(f)|寄存器间接寻址|EA = (R)|✅|寄存器R中存的是地址，如 `MOV AX, [BX]`，适合数组遍历|
|(g)|偏移寻址|EA = (R) + A|✅|基址/变址 + 偏移，如 `MOV AX, [BX+SI+100H]`，支持模块化和数组|
|(h)|堆栈寻址|EA = SP（栈顶）|✅|自动管理栈顶，用于函数调用、中断，如 `PUSH/POP`​|
