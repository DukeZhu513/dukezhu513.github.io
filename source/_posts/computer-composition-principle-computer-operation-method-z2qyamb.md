---
title: 计算机组成原理：计算机的运算方法
date: '2025-09-16 16:35:47'
updated: '2025-09-16 22:43:27'
permalink: /post/computer-composition-principle-computer-operation-method-z2qyamb.html
comments: true
toc: true
---



# 计算机组成原理：计算机的运算方法

## **考点1：进制转换**

### 一、什么是进制？

进制 = 进位计数制  
是人为定义的带进位的计数方法。  
对于任意一种 X 进制，表示每一位上的数在运算时都是**逢X进一位**。

### 二、进制的基本要素

一个进制包含：

1. **数码**：用于表示该进制的符号集合
2. **基数**：该进制中可用数码的个数（十进制基数为10，二进制基数为2）
3. **数位**：数码在一个数中所处的位置（从右往左依次是第0位、第1位……）
4. **权**：某位上数字的实际值 = 数码 × 基数的幂次

    权 = 基数^位置（从右往左，从0开始）

### 三、常见进制及相互转换

#### （1）十进制 → 非十进制（整数部分）

方法：**除基取余法**

步骤：

1. 将原数不断除以目标进制的基数；
2. 每次记录余数；
3. 最后按**逆序排列余数**即得结果。

 将 `(19)₁₀` 转换为二进制

```
19 ÷ 2 = 9 …… 1  
9  ÷ 2 = 4 …… 1  
4  ÷ 2 = 2 …… 0  
2  ÷ 2 = 1 …… 0  
1  ÷ 2 = 0 …… 1  
↓ 逆序排列 → (10011)₂
```

#### （2）十进制 → 非十进制（小数部分）

方法：**乘基取整法**

步骤：

1. 将小数部分不断乘以目标进制的基数；
2. 每次取整数部分；
3. 直到小数部分为0或达到精度要求；
4. 取出整数部分**顺序排列**即得结果。

例：将 `(0.6875)₁₀` 转换为二进制

```
0.6875 × 2 = 1.375 → 整数部分：1  
0.375  × 2 = 0.75  → 整数部分：0  
0.75   × 2 = 1.5   → 整数部分：1  
0.5    × 2 = 1.0   → 整数部分：1  
↓ 顺序排列 → (0.1011)₂
```

#### （3）N进制 ↔ M进制（非十进制之间）

**通用方法**：先转为十进制，再转为目标进制。

**特殊技巧**：

二进制 ↔ 八进制：每**三位一组**分组（从右向左）

二进制 ↔ 十六进制：每**四位一组**分组，例如：`(1101011.11)₂` → 分组为 `0001 1010 11.11` → `(1A.B)₁₆`​

## **考点2：BCD码**

### 一、BCD码定义

BCD码（Binary-Coded Decimal）：用**4位二进制数**表示**1位十进制数**。

### 二、分类

|类型|特点|
| ------| ----------------------------------------|
|**有权BCD码**|各位有固定权重，可直接按权相加还原数值|
|**无权BCD码**|不具备固定的权值，但具有其他优点|

#### （1）有权BCD码

**8421码**：最常用，权重为 8,4,2,1

表格如下：

|十进制|8421 BCD码|权值说明|
| --------| ------------| ----------|
|0|0000|——|
|1|0001|1|
|2|0010|2|
|3|0011|2+1|
|4|0100|4|
|5|0101|4+1|
|6|0110|4+2|
|7|0111|4+2+1|
|8|1000|8|
|9|1001|8+1|

 注意：BCD码只表示0~9，不表示10及以上（如10不能用1010表示）

#### （2）无权BCD码

**余3码**：每个十进制数加3后再编码，如：3 → 3+3=6 → 0110

**余3循环码**：具有相邻性，便于电路设计

**格雷码**：相邻两个代码仅一位不同（抗干扰好）

## **考点3：原码、反码、补码、移码**

### 一、机器数的分类

在计算机中，参与运算的数据分为两类：

|类别|特点|
| ------| --------------------------------------------------------------------------------------|
|**无符号数**|所有位均为数值位，无符号位，表示范围：0 ~ 2ⁿ⁻¹（n为字长）<br />如8位无符号数：0 ~ 255|
|**有符号数**|最高位为符号位：<br />- 0 表示正<br />- 1 表示负<br />其余位为数值位|

> 示例：8位字长下
>
> ​`+19.75` 的真值 → 机器数：`0 10011.11`​
>
> ​`-19.75` 的真值 → 机器数：`1 10011.11`​

### 二、四种编码方式

|编码|定义|正数|负数|
| ------| -------------------------------| ------------| ---------------------------|
|**原码**|[X]原 = 符号位 + 绝对值|与真值相同|符号位为1，数值位为绝对值|
|**反码**|[X]反 = 符号位 + 数值位取反|与原码相同|符号位不变，其余位取反|
|**补码**|[X]补 = [X]反 + 1（或模运算）|与原码相同|反码 + 1|
|**移码**|[X]移 = [X]补 的符号位取反|与补码相反|补码符号位翻转|

> 规律总结：
>
> 当 x > 0：[X]原 = [X]反 = [X]补
>
> 当 x < 0：[X]补 = [X]反 + 1；[X]移 = [X]补 的符号位取反

举个例子：x = -19.75，假设用8位表示（含符号位）

- 真值：-19.75 = -10011.11B
- 原码：`1 10011.11`​
- 反码：`1 01100.00`​
- 补码：`1 01100.01` ← 反码+1
- 移码：`0 01100.01` ← 补码符号位取反

### 三、为什么用补码？

在计算机中，减法可以转化为加负数的补码，在使用补码后，加法器无需区分正负号，可以统一处理，进而实现了“统一加法电路完成加减运算”。

举个例子：计算 `15 - 7`​

[15]补 = 0 1111

[-7]补 = 1 1001（先求7的补码再变负）

相加：

```
  0 1111
+ 1 1001
--------
1 10000 → 忽略溢出位 → 结果为 01000 = 8
```

### 四、溢出判断

|方法|原理|
| ------| ---------------------------------------------------------|
|**双符号位法（变形补码）**|使用两位符号位，正常为 `00` 或 `11`，若出现 `01` 或 `10` 则溢出|
|**异或判断法**|若符号位与最高数值位异或结果为1，则溢出|

两个正数相加结果为负 → 溢出，两个负数相加结果为正 → 溢出

## **考点4：定点与浮点表示**

定点：小数点位置固定；浮点：小数点位置可变，适合表示大范围数据

### 一、定点表示

小数点隐含在某个固定位置

分类：

- **定点整数**：小数点在最低位之后

  - 如：`1001.00` 表示 9
- **定点小数**：小数点在最高位之后

  - 如：`0.1001` 表示 0.5625

优点：结构简单，速度快；缺点：表示范围小，不适合科学计算

### 二、浮点表示（IEEE 754标准）

IEEE 754 是国际通用的浮点数标准，分为两种主要格式：

|类型|字长|结构|
| --------| ------| -------------------------------------|
|单精度|32位|​`S E M`：1位符号 + 8位阶码 + 23位尾数|
|双精度|64位|​`S E M`：1位符号 + 11位阶码 + 52位尾数|

位序示意图：

```
32位：[S][E(8位)][M(23位)]
       ↑     ↑        ↑
      31    30-23     22-0

64位：[S][E(11位)][M(52位)]
       ↑     ↑         ↑
      63    62-52     51-0
```

注意：符号位S，0为正，1为负；阶码E，用**偏置值**表示（避免负数）；尾数M，隐含前导1（规格化时）

#### 2. 真值计算公式

对于一个**规格化的**浮点数 x：

**32位单精度**：

$$
x = (-1)^S \times (1.M) \times 2^{(E - 127)}
$$

**64位双精度**：

$$
x = (-1)^S \times (1.M) \times 2^{(E - 1023)}
$$

其中：$(-1)^S$表示决定正负号；$(1.M)$表示尾数部分，其中“1.”是隐含的（即实际为 1 + 小数部分）；指数部分使用偏置值：32位偏置=127，64位偏置=1023

#### 3. 【例题】计算 IEEE 754 浮点数真值

**题目**：计算 IEEE 754 标准浮点数 `1 10000001 01000000000000000000000` 的真值

|部分|值|解析|
| -------------| ------------------| -----------------------------------|
|S（符号位）|1|表示该数为**负数**|
|E（阶码）|​`10000001`₂ = 129₁₀|偏置后真实指数 e = 129 - 127 = **2**|
|M（尾数）|​`01000000000000000000000`​|表示小数部分，补上隐含的1 → `1.01`₂|

代入公式：

$$
x = (-1)^1 \times (1.01)_2 \times 2^2 = -1.25_{10} \times 4 = -5.0
$$

答案： **-5.0**

## **考点5：定点运算**

### 一、移位操作

移位是实现乘除的基础操作，常见有**左移**和**右移**

#### 1. 无符号数移位

- 左移：相当于 ×2（每左移一位）
- 右移：相当于 ÷2（每右移一位）

#### 2. 有符号数移位（以补码为例）

|移位类型|规则|作用|
| ----------| --------------------| --------------------------|
|**算术左移**|左移，低位补0|相当于 ×2，但可能溢出|
|**算术右移**|右移，高位补符号位|相当于 ÷2，保持符号不变|

##### （1）A = +26 → [A]补 = 0 0011010

|操作|机器数|真值|
| ----------| -----------| ------|
|移位前|0,0011010|+26|
|左移一位|0,0110100|+52|
|左移两位|0,1101000|+104|
|右移一位|0,0001101|+13|
|右移两位|0,0000110|+6|

##### （2）A = -26 → [A]补 = 1 1100110

|操作|机器数|真值|
| ----------| -----------| ------|
|移位前|1,1100110|-26|
|左移一位|1,1001100|-52|
|左移两位|1,0011000|-104|
|右移一位|1,1110011|-13|
|右移两位|1,1111001|-6|

### 二、加减运算

计算机中采用 **补码** 进行加减运算

#### 1. 原理

无论操作数正负，均用补码表示

- 减法 → 加负数的补码
- 符号位参与运算，与数值位同等对待
- 最高位产生的**进位自然丢弃**（无需特殊处理）

#### 2. 溢出判断

当两个同号数相加，结果异号从而发生溢出

|方法|原理|
| ------| -------------------------------------------------------------|
|**双符号位法（变形补码）**|使用两位符号位：00（正）、11（负）<br />若出现 01 或 10 → 溢出|
|**异或判断法**|若符号位与最高数值位异或结果为1 → 溢出|

示例：

​`[X]补 = 01111`（+15）

​`[Y]补 = 01001`（+9）

相加得：`10100` → 符号位为1，但两数均为正 → **溢出**

#### 3. 例题演示：补码加法

计算：`15 + (-7)`​

[15]补 = 0 1111

[-7]补 = 1 1001

相加：

```
  0 1111
+ 1 1001
--------
1 10000 → 忽略最高位进位 → 01000 = 8 

结果正确，无溢出。
```

‍

‍
