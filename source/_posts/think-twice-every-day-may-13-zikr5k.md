---
title: 每日三思（5月13日）
date: '2025-05-13 23:21:27'
categories:
  - 每日总结
tags:
  - C++
  - 机器学习  
updated: '2025-05-14 00:23:48'
permalink: /post/think-twice-every-day-may-13-zikr5k.html
comments: true
toc: true
---



# 每日三思（5月13日）

# 问题一：今天学了什么？

今天完成了string中的两道题，同时学习了神经网络的算法实现。

# 问题二：总结一下两种题的解法

## 一、单词个数统计问题

### 1. 输入处理

```cpp
char arr[200] = { 0 };
fgets(arr, 200, stdin);
```

* 使用 `fgets`​ 安全地读取一行字符串。

### 2. 遍历字符进行统计

```cpp
while (true) {
    if (arr[i] == '\0' || arr[i] == '\n') break;
    else if (arr[i] == ' ') isSpace = true;
    else {
        ++alphaCount;
        if (isSpace) ++wordCount;
        ...
        isSpace = false;
    }
    ++i;
}
```

* 遇到空格说明进入“空白”状态，下一个非空字符表示新单词开始。
* 每个字母都计入 `alphaCount`​，并更新 `wordCount`​。
* 将大写字母统一转为小写后，记录在 `map<char, int>`​ 中。

### 3. 统计结果输出

```cpp
printf("%d\n", alphaCount);     // 总字母数
printf("%d\n", wordCount);      // 单词数量
...
printf("%c", it->first);        // 出现次数最多的字母
printf("\n");
printf("%d\n", maxTimes);       // 最多出现次数
```

### **关键点总结：**

|功能|实现方式|
| ----------------| -----------------------------------------------|
|字符串读取|​`fgets()`​ 防止溢出|
|字母计数|遇到非空格就增加计数器|
|单词计数|空格后第一个字符代表新单词|
|字母频率统计|使用 `map<char, int>`​ 自动按字母归类|
|大小写统一|大写字母转成小写再统计|
|找最大频次字母|先找最大值，再遍历 map 输出所有等于最大值的键|

## 二、浮点数的加法

### 1. **输入读取与分割**

```cpp
string a = arra;
string b = arrb;

string ia = GetInteger(a); // 整数部分
string ib = GetInteger(b);
string fa = GetFraction(a); // 小数部分
string fb = GetFraction(b);
```

使用 `GetInteger()`​ 和 `GetFraction()`​ 函数从字符串中提取出整数和小数部分。

### 2. **小数部分加法（FractionPlus）**

```cpp
void FractionPlus(string& res, int& carry, string fa, string fb)
```

补零对齐小数位，从右往左逐位相加，注意进位处理。最终返回小数部分的结果和是否向整数部分进位。

**关键技巧：**

* 补零操作确保两小数长度一致。
* 加法时使用字符运算（如 `'5' + '7' - '0' = 12`​），再转回字符。
* 进位标志 `carry`​ 会传递到整数部分。

### 3. **整数部分加法（IntegerPlus）**

```cpp
void IntegerPlus(string& res, int& carry, string ia, string ib)
```

从个位开始模拟竖式加法。同时需要分别处理两数都还有位、一个有位、都没有但需要进位的情况。同时需要使用 `insert(res.begin(), ...)`​ 来保证高位在前。

**关键技巧：**

* 支持不同长度的整数相加。
* 处理进位时逻辑清晰，包括最后可能多一位（如 `999 + 1 = 1000`​）。

### 4. **最终拼接输出**

```cpp
printf("%s.%s\n", ires.c_str(), fres.c_str());
```

把整数和小数部分用 `.`​ 拼接成完整结果输出。

### 关键点总结：

|模块|方法|
| ------------| --------------------------------|
|输入处理|使用字符串读入，避免溢出|
|分割处理|利用 `find('.')`​ 拆分整数和小数部分|
|高精度加法|模拟人工竖式加法，从低位到高位|
|小数处理|补零对齐后加法，注意进位|
|整数处理|双指针逆序加法，插入结果头部|
|输出拼接|合并整数和小数部分|

# 问题三：机器学习视角下的的人生优化算法

> **我们如何在有限的信息和资源下，通过不断试错和调整，找到让人生最幸福、最有意义的生活方式？**

## 一、把人生看作一个“优化问题”

我们可以形式化地定义一个人生目标函数如下：

$$
\text{Maximize } H(x_1, x_2, ..., x_n)
$$

其中：

* $H$：代表你人生的“幸福感”或“满意度”
* $x_i$：代表你生活的各种变量，比如：

  时间分配（工作、娱乐、学习）

  情感关系（亲情、友情、爱情）

  健康状态（饮食、运动、作息）

  职业发展（收入、成长、成就感）
* 心态情绪（压力、焦虑、满足感）

这个函数非常复杂，且每个人都不一样。它没有解析式，也没有导数，但我们仍然可以尝试去“优化”它。

##  二、用“梯度下降”的方式来优化人生

### 1. **局部搜索 vs 全局最优**

就像梯度下降只能保证找到局部最优解一样：

> 我们无法预知未来，也无法看到所有可能的人生路径，只能根据当前的状态，做出看起来最好的选择。

例如：今天是加班还是健身？是换一个学习研究的方法，还是继续这个方向学习？

我们只能依据当下的判断（梯度），迈出一小步。

### 2. **学习率（Step Size）——改变的速度**

学习率决定了你每次尝试改变的步伐有多大。

|学习率|人生表现|
| --------| ----------------------------------------------|
|太大|冒险激进，容易失控（如裸辞、突然搬家、巨变）|
|太小|进展缓慢，容易陷入舒适区|
|合适|稳中有进，持续进步|

改变要有节奏，太快会迷失方向，太慢会失去动

### 3. **反馈机制（Loss + Gradient）——自我反思**

在机器学习中，梯度来自损失函数；在人生中，我们需要靠**反馈系统**来知道我们做得好不好。

这些反馈包括：情绪感受（开心/痛苦）、外部评价  (他人看法、成就）、自我评估（是否在成长？是否有意义？）

 如果你长期缺乏反馈机制，就很容易陷入“平坦区”或“鞍点”，即看似稳定，实则停滞。

### 4. **随机性与探索（Stochastic Gradient Descent）**

SGD 的核心是每次只看一部分数据，虽然不稳定，但能跳出局部最优。

在人生中，这也意味着：

> 要敢于尝试不同的生活方式、职业路径、人际关系，才能避免陷入单一维度的“最优陷阱”。

### 5. **收敛与满意解（Satisficing）**

人生不会真正“收敛”，我们最终追求的是一个“满意解”，而不是绝对最优。只要自己满意，便最优解了。
